package main
多重赋值在go语言的错误处理和函数返回值中会大量使用


匿名变量不占用内存空间，不会分配内存。
匿名变量与匿名变量之间也不会因为多次声明而无法使用

一个变量(常量，类型或函数)在程序中都有一定的作用范围，称为作用于


函数内定义的变量称为局部变量
函数外定义的变量称为全局变量
函数定义中的变量称为形式参数





全局变量
在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，
就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用"import"
关键字引入全局变量所在源文件之后才能使用这个全局变量


全局变量必须以var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写

go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑


形式参数

在定义函数时函数后面括号中的变量叫做形式参数

形式参数只在函数调用时才会生效，函数调用结束后就会销毁，
在函数未被调用时，函数的形参并不占用实际的额存储单元，也没有实际值


形式参数会作为函数的局部变量来使用


转义字符串

\n :　换行符
\r : 回车符
\t : tab 键
\u 或\U ：Unicode字符
\\ :反斜杠自身


字符串实现基于UTF-8编码

go语言中字符串的内部实现使用utf-8编码，通过rune类型，可以方便地堆每个UTF-8
字符进行访问。
也支持按照传统的ASCII码方式逐字符进行访问


使用双引号写字符串的方式，称为字符串字面量

这种双引号不能跨行，如果想要在源码中嵌入一个多行字符串时，
就必须使用`反引号

在这种方式下，反引号换行将被作为字符串中的换行，但是所有的转义字符均微笑，文本将会
原样输出

fmt.Sprintf(格式化输出)

fmt.Sprintf(格式化样式，参数列表)

格式化样式：　　字符串形式，格式化动词以%开头
参数列表：　　多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行是会报错


StringBuilder　的机制来进行搞笑的字符串连接

bytes.Buffer是可以缓冲病可以往里面写入各种字节数组的。
字符串也是一种字节数组，使用WriteString()方法进行写入

将需要连接的字符串，通过调用WriteString()方法，写入stringBuilder中，然后
再通过stringBuild.String()方法将缓冲转换为字符串


声明字节缓冲
把字符串写入缓冲
将缓冲以字符串输出

GO语言的字符串无法直接修改每一个字符元素，只能通过重新构造新的字符串并
赋值给原来的字符串变量实现

ｇｏ中字符串是不可变的

字符串不可变的很多好处
天生线程安全，都是只读对象，无须加锁；方便内幕才能内存共享，
而不必使用写时赋值(Copy On Write)等技术，
字符串hashy值也只需要制作一份

[]byte在go语言中是可变的，本身就是以切片


go语言中的字符串是不可变的
修改字符串时，可以将字符串转换为[]byte进行修改
[]byte和string可以通过强制类型转换

go内建函数 len()可以用来获取字符串，切片，通道channel的差大怒



一般游戏中咋登录时都需要输入名字，而名字一般有长度限制。
考虑到使用中午的名字，就需要检测字符串的UTF-8格式的长度

ASCII字符串长度使用len()函数
Unicode字符串长度使用utf8.Rune.CountingString()函数。。

遍历字符串的两个方法

遍历每一个ASCII字符

遍历ASCII字符使用for的数值循环进行遍历，直接取每个字符串的下边获取ASCII字符


由于没有使用Unicode，汉子没显示为乱码

按Unicode字符遍历字符串


Ascii字符串已办理直接使用下标
Unicode字符串遍历用for range


字符串截取(获取字符串的每一段字符)
获取字符串的某一段字符是开发中常用的操作，一般将字符串中的某一段字符叫做
子串(substring)


string.Index()函数在字符串中搜索另外一个子串

字符串索引比较常用的方法\
strings.Index:正向搜索子字符串
strings.LastIndex:反向搜索子字符串
搜索的起始位置可以通过切片偏移制作

字符串中的灭一个元素叫做“字符”，在百丽或单个获取字符串元素时可以获得字符


go的字符有两种


1. uint8类型，或byte类型，代表ASCII码的一个字符

2. rune类型，代表一个utf-8 处理中文，日文是
需要用到rune类型，rune类型等价于int32类型

byte类型是uint8的别名

go也支持Unicode(UTF-8)，字符同样称为Unicode代码点或runes
并在内存中使用int来表示。

在书写Unicode字符时，需要在16进制数之前加上前缀\u或\U
因为Unicode至少占用2个字节，
所以我们使用init16或int类型来表示

如果需要使用到4个字节，则使用\u前缀
格式化说明%c用于表示字符
当和字符配合使用时，%v或%d会输出用于表示该字符的整数

%U输出格式为U+hhhh的字符串


Unicode包中的用于测试字符的函数，返回布尔值


ch代表字符

判断是否为字母：unicode.IsLetter(ch)
潘丹是否为数字:unicode.IsDigit(ch)
判断是否为空白符号：  unicode.IsSpace(ch)

在必要可行的情况下，一个类型的值可以被转换为另一个类型的值。
由于go语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明

valueOfTypeB = typeB(valueOfTypeA)


类型B的值 = 类型B(类型A的值)


a:=5.0
b :=int(a)

类型转换只能在定义正确的情况下转换成
只有相同底层类型的变量之间可以进行相互转换

不同底层类型的变量相互转换时会引发编译错误(如将bool类型转换为int类型)


浮点数在转换为整型时，会将小数部分去掉，只保留整数部分


go提供了控制数据结构指针的能力
不能进行指针运算
go允许控制特定集合的数据结构，分配的数据以及内存访问模式。
指针是系统编程，操作系统或网络应用常用的变量

指针(pointer)在go中分拆为两部分

1.类型指针
2. 切片


类型指针，允许堆这个指针了新的数据进行修改，传递数据可以直接使用指针
而不需拷贝主句，类型指针不能进行偏移和运算

切片，由指向起始元素的原始指针，元素数量和容量组成


受益于这样的约束和拆分，go语言的指针类型变量即拥有指针高小访问的特点，又不会
发生指针偏移，
从而避免非法修改关键性数据的问题。
垃圾回收也比较容易堆不会发生便宜的指针进行检索和回收

切片比原始指针更安全，
切片在发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃


操作系统使用c语言及指针进行编写

指针地址，指针类型，指针取值

认识指针地址和指针而理性

一个指针变量可以指向一个值的内存你地址，它所指向的值的内存地址32和64位
机器上分配4或8个字节，
占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配
到任何变量时，它的默认值为nil
指针变量通常缩写为 ptr

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置

go语言中使用在变量名前添加&操作符(前缀）来获取变量的内存地址(取地址操作）

ptr := &v // v的类型T

其中v代表被取地址的变量，变量v的地址使用变量ptr进行接收
ptr的类型为 *T，称作T的指针类型
*代表指针

变量，指针，地址  每个变量都有地址，这个地址就是指针的值

从指针获取指针指向的值

当使用&操作符对普通变量进行取地址操作并得到变量的指针后，
可以对象指针使用*操作，也就是指针



取地址操作符&和取值操作符*是一对互补操作
&取地址，
×根据地址取出地址指向的指向的值


变量，指针地址，指针变量，取地址，取值的关系

1.对变量进行取地址操作使用&,可以获得这个变量的指针变量
2. 指针变量的值是指针地址

& 指针地址，指针类型
× 取值
&× 指针取值




3. 对指针变量进行取值操作*,可以获得指针变量指向的原变量的值


使用指针修改值

铜鼓欧指针不仅可以取值，也可以修改值


示例： 使用指针变量获取命令行的输入细腻系


flag包实现了堆命令行的解析
flag包使得开发命令行工具更加简单


通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数
经过flag包的解析后即可获取命令行的数据

创建指针的方法--new()函数


new(类型)


new()函数可以创建一个对应类型的指针，创建过程会分配内存
被床架你的指针指向默认值
Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。

指针

foo()函数返回一个局部变量的指针

foo函数里的变量t逃逸了，

堆上动态分配内存比栈上静态分配内存，开销大很多

const ，用于存储不会改变的数据

const pi = 3.14

const iota

无类型常量


const+iota 间接实现枚举

枚举类型转换为字符串


type 关键字(类型别名)


type byte = uint8
type rune = int32


type TypeAlias = Type

类型别名和类型定义

非本地类型不能定义方法

在结构体成员嵌入时使用别名

 结构体重命名类似继承类


go的语法元素5个
标识符
关键字
操作符
分隔符
字面量


break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var 



append bool byte cap close complex complex64 complex128
unit16 copy false float32 float64 imag int int8 int16
uint32 int32 int64 iota len make new nil  
panic uint64 print println real recover
string true uint uint8 uintptr

strconv包：字符串和数值类型的相互转换


strconv

字符串转int: Atoi()
int转字符串 ：Itoa()

Parse类函数将string转换为指定的数值类型：
ParseBool(), ParseFloat(), ParseInt(),ParseUint()


Format类函数将指定的数值类型转string类型
FormatBool(),FormatFloat(),FormatInt(),FormatUint()

Append类函数用于将指定的数值类型转换成字符串后追加到一个切片中：
AppendBool(),AppendFloat(),AppendInt(),AppendUint()



func Atoi(s string)(int,error)


由于string类型可能无法转换为int类型，所以这个函数有两个返回值：第一个返回值是转换
成的int类型的值，第二个返回值是转换是否成功

ParseFloat() 只能接收float64类型的浮点数
ParseInt()和ParseUint()有3个参数：


s：表示需要转换的字符串
bitSize:表示转换为多少位的int或uint
base 表示以什么进制的方式去解析给定的字符串

func ParseInt(s string,base int,bitSize int)(i int64,err error)
func ParseUint(s string,base int,bitSize int)(uint64,error)



func FormatInt(i int64,base int) string


容器(container)

变量在一定程度上能满足函数及代码要求

复杂类型，具有各种形式的存储和处理数据的功能，就是容器


C语言没有提供容器封装，开发者需要自己根据性能需要进行封装，或使用第三方提供的容器

c++语言的容器通过标准库提供，如vector对应数组，list对应双链表，map对应映射

数组

数组是一个由固定长度特定类型元素组成的序列，一个数组可以由零个或多个元素组成。
因为数组的长度是固定的。所以在go语言中很少直接使用数组

和数组对应的数据类型是Slice(切片)，Slice是可以增长和收缩的动态序列


var 数组变量名[元素数量]Type
数组变量名：数组声明及使用时的变量名
元素数量：数组的元素数量，可以是一个表达式，但最终通过编译器计算的结果必须是整型数值，元素
数量不能含有运行时才能确认大小的数值


Type:可以是任意基本类型，包含数组本身，类型为数组本身时，可以实现多维数组


数组的每个元素都可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减去1的位置，
内置函数len()可以返回数组中元素额个数


默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对应数字类型来说就是0
同时也可以使用数字下面的字面值语法
用一组值来初始化数组


在数组的定义中，如果在数组长度的位置出现"..."省略号，
则表示数组的长度是根据初始化中的个数来计算的
因此上莫得

数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同数组类型
数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定


比较两个数组是否相等
== != 
只有当两个数组的所有元素都是相等的数组才是相等的，不能比较两个类型不同的数组，
否则程序将无法完成编译

遍历数组---访问每一个数组元素


go允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值，
多维数组尤其适合管理具有父子关系或与坐标系相关联的数组

var array_name [size1][size2] ...[sizen] array_type


二维数组本质上是由多个以为数组组成的


切片slice 是数组的一个连续片段的引用，所以切片是一个引用类型(类似c/c++中的数组类型，或python中的list类型)
这个片段可以是整个数组，也可以是起始或终止索引标识的一些项的子集
终止索引标识的项不包括在切片内


切片的内部结构包含地址，大小和容量，切片一般用于快速地操作一块数据集合


从连续内存区域生成切片是常见的操作

slice[start:end]


1. 从指定范围中生成切片
2. 表示原有切片[:]
3.重置切片，清空拥有的元素[0:0]



使用类型分支判断接口类型
error接口：返回错误信息
error 基本用法
type error interface {
    Error() string
}






多维数组

var sliceNmae []..[]slicetTYpE 

map() 映射，一种元素对(pair)的无序结婚，pair对应一个key(索引)和一个value(值)
关联数组或字典


var name map[key]vaule


在声明的时候不需要知道map的长度，因为map是可以动态增长的的。未初始化的map的值是nil
使用len()可以获取map中pair的数目

修改引用也会修改之前被引用的对象的值


可以使用make(),但不能使用new()来构造map,如果错误的使用new()分配了一个引用独享，
会获得一个空引用的指针，
相当于声明了一个未初始化的变量并且取了它的地址


map容量

和数组不同，map可以根据新增的key-value动态的伸缩，
用切片作为map的值

mp1 := make(map[int][]int)
mp2 := make(map[int]*[]int)

遍历map(访问map中的每一个键值对

)

默认是只遍历key

不需要的键使用 _改为匿名变量的形式

遍历输出元素的顺序与填充顺序无关，不能期望map在遍历时返回某种期望殊勋的结果

先排序，再遍历

sort.Strings的作用是对传入的字符串切片进行字符串字符的升序排列


map元素的删除与清空


delete(),用于删除容器内的元素，

使用使用delete()函数从map中删除键值对

delete(map,key)


其中map为要删除的map实例，k

清空map中的所有元素
go语言中没有为map提供任何清空所有元素的函数，方法
清空map的唯一办法就是重新make一个新的map
不用担心垃圾回收的效率，go语言中的并行垃圾回收小龙比写一个清空函数要高校很多

多建索引，，多个数值条件可以同事查询


分别给予传统的哈希值的多键索引和利用map特性的
所以见素以查询


给予哈希值的多建索引及查询

传统的数据索引过程是将输入的数据做特征值
将特征使用某种算法转我整数，也就是哈希值，使用整型值做索引
将特征转为字符串，使用字符串做索引


数据给予特征值构建好索引后，就可以进行查询。
查询时，重复这个过程，将查询条件转为特征值，使用特征值进行查询得到结果


构建好索引的数据中查询需要的数据流程：
给定查询条件(名字，年龄)
根据查询条件构建查询键
查询键生成哈希值
根据哈希值在索引中查询数据集合
遍历数据集合逐个与条件比对
多得结果

利用map特性的多见索引及查询

使用结构体进行多键索引和查询比传统的写法更简单，
最主要的区别是无须准备哈希函数级相应的子弹
无须做哈希合并

利用map特性的多键索引和查询的


go语言的底层会为map的键自动构建哈希值。
能够构建哈希值的类型必须是非动态类型，非指针，函数，闭包


非动态类型：可用数组，不能用切片
非指针：每个指针数值都不同，失去哈希意义
函数，闭包不嗯给你作为map的键


go语言中的Map在并发情况下，只读是线程安全的，同时读写是线程不安全的

并发的map读和map写，使用了两个并发函数不但对map进行读和写而发生竞态问题，
map内部会对这种并发操作进行检查并提前发现

需要并发读写时，一般的做法是加锁，但是效率不高。1.9版本后
提供了sync.Map结构


sync.Map的特性


1.无须初始化，直接声明即可
2.sync.Map不能使用map的方式进行取值和设置等操作，而是使用sync.Map的方法进行调用，
Store表示存储，Load表示获取，Delete表示删除

3. 使用Range配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，
Range参数中回调函数的返回值在需要继续迭代时，返回true,终止迭代遍历时，返回false


声明scene,类型为sync.Map，注意，sync.Map不能使用make创建
将一系列键值对保存到sync.Map中，sync.Map将键额值以interface{}类型进行保存
提供一个sync.Map的键给scene.Load()方法后将查询到键对应的值返回
sync.Map的Delete可以使用指定键将对应的键值对删除
Range()方法可以遍历sync.Map，遍历需要提供一个匿名函数，参数为k,v,类型为interface{}
每次Range()在遍历一个元素时，都会调用这个匿名函数吧结果返回


sync.Map没有提供获取map数量的方法，替代方法是在获取sync.Map时遍历自行计算数量，
sync.Map为了保证并发安全有一些性能损失，
因此在非并发情况下，使用map相比使用sync.Map会有更好的性能

列表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，
列表有多种实现方式，如单链表，双链表

在go语言中，列表使用container/list包来实现，内部的实现原理是双链表，
列表能够高效地进行任意位置的元素插入和删除

初始化列表
list的初始化有两种方法：New()函数和var关键字声明

1. name := list.New(0

2. var name list.List

列表与切片和map不同的是，列表并没有具体类型额限制，因此，列表的元素可以是任意类型，
例如，给列表中放入了一个interface{}类型的值，取出值后，如果要将interface{}转换为为其他类型将会宕机

在列表中插入插入元素

双链表支持从队列前方或后方插入元素，PushFront,PushBack

这个两个方法会返回一个*list.Element结构，如果在以后的使用中需要删除
插入的元素，则只能通过*list.Element配合Remove()
方法进行删除，这种方法可以让删除

从列表中删除严肃

列表插入函数的返回值会提供一个*list.Element结构，这个结构记录这列表
元素的值以及其他节点之间的关系等信息，
从列表中删除元素时，需要用到这个机构进行快速删除

遍历列表----访问列表的每一个元素

遍历双链表需要配合Front()函数获取头元素，
遍历时只要元素不为空就可以继续进行，
每一次遍历都会调用元素的Next()函数

nil: 空值、零值


在go语言中，布尔类型的零值(初始值)为false,数值类型的零值为0
字符串类型的零值为空字符串""
指针，切片，映射，通道，函数和接口的零值都是nil

nil标识符是不能比较的
这与python不同
nil不是关键字或保留字
nil没有默认类型
不同类型的nil的指针是一样的
但是不同类型的nil是不能比较的
两种相同类型的nil值也可能无法比较


零值是go语言中变量的在声明只会但是未初始化被赋予的该类型的一个默认值

不同而理性的nil值占用的内存代销可能是不一样的
一个类型的所有的值的内存布局都是一样的，nil也不列外，
nil的大小与同类型中的非nil类型的大小是一样的。
但是不同类型的nil值的大小可能不同

具体的大小取决于编译器和脚骨

go语言make和new关键字的区别及实现原理

go语言中new和make是两个内置函数，主要用来创建并分配类型的内存。


new只分配内存
make只能用于slice,map和channel的初始化

funn new(Type)*Type


new函数只接受一个参数，这个参数是一个类型，并且返回一个指向该类型内存的指针。
同时new函数会分配的内存置为零，也就是类型的零值


new函数不仅仅能够为系统默认的数据类型，分配空间，自定义类型也可以使用new函数来分配空间

type Student struct{
	
这就是new函数，它返回永远是类型的指针，指针指向分配类型的内存地址

make

make也是用于内存分配的，但是和new不同，它只用于chan,map以及slice的内存创建，
而且它返回类型就是这三个类型本身，而不是他们的指针类型，
因为这个三种类型就是引用类型，所以就没有必要返回他们的指针了


func make(t Type,size ... IntegerType) Type


make函数的t参数必须是chan(通道).map(字典),slice(切片)中的一个，并且返回值也是类型本身


make函数只用于map,slice和channel,并且不反悔指针。
如果想要获取的一个显式的指针，可以使用new函数进行分配，或显式地使用一个变量的地址


new和make的区别


make只能用来分配及初始化类型为slice,map,chan的数据。new可以分配任意类型的数据
new分配返回的是指针，即类型*Type.make返回引用，即Type
new分配的空间被清零。make分配空间后，会进行初始化


在编译器的类型检查阶段，go语言其实就将代表make关键字的OMAKE节点根据参数类型的不同转换成了
OMAKESLICE,OMAKEMAP,OMAKECHAN三种不同类型的节点，这些节点最终也会调用不同的运行
时函数来初始化数据结构

new

内置函数new会在编译器的SSA代码生成阶段经过callnew函数的处理，如果请求创建的类型大小是0，
那么就会返回一个表示空指针的zerobase变量，
在遇到其他情况时会将关键字转换成newobject

，会取传入类型的大小并调用mallocgc在堆上申请一片
大小合适的内存空间并返回指向这片内存空间的指针

func newobject(typ *_type) unsafe.Pointer{
	return mallocgo(type.size,type,true)
}


golang函数如果返回值定义了变量，return后面必须跟你这表达式或值
如果没有定义变量，return必须显示返回对象

当return后面为空时，函数声明时的返回内容 (a int )会把a返回值
当return不为空时，会把return后面的值作为返回值


for中的初始语句，开始xun

for range 键值循环

for k,v := range coll{
}


遍历数组，切片--获得索引和值
遍历字符串--获得字符
遍历map--获得map的键和值
遍历通道(channel)--接收通道数据

for range可以遍历通道(channel)
但是通道在遍历时，只输出一个值，即管道内的类型对应的数据



goto语句通过标签进行代码间的无条件跳转，同时goto语句在快速跳出循环，避免重复退出上也有一定的帮助


使用goto集中处理错误


go语言func



函数是组织好的，可重复使用的，用来实现单一或相关联功能呢的代码段，其可以提高应用的默认性和重复利用率

go语言支持普通函数，匿名函数和必报
函数是一等公民，
函数本身可以作为值传递
支持匿名函数和闭包(closure)
函数可以满足接口

当函数执行到代码块的最后一行}或return语句的时候退出
其中return语句可以带零个或多个参数，这些参数将作为返回值供
调用者使用，简单的return语句也可以用来结束for的死循环或结束一个协成 goroutine

普通的带有名字的函数
匿名函数或lambda函数
方法

func 函数名(形式参数列表)(返回值列表){
	函数体
}


空白标识符_可以强调某个参数未被使用

函数的类型被称为函数的标识符，如果两个函数形式参数列表和返回值列表中的变量类型一一对应，
那么这两个函数被认为有相同的类型和标识符，
形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示


每一个函数在调用时都必须按照声明顺序为所有参数提供实参(参数值)
在调用函数时，go语言没有默认参数值，也没有任何方法可以通过参数名调用
指定形参，在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，
堆形参进行修改不会影响实参，
但是，如果实参包括引用类型，如指引，slice(切片)，map，function,channel等
类型，实参可能会由于函数的简介引用被修改


函数的返回值

go语言支持多返回值，多返回值方便获得函数执行后的多个返回参数，
go语言经常使用多返回值的最后以参数返回函数执行

conn,err := connectToNetwork()

conn,表示连接对象
err，表示返回错误信息


go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更方便


1. 同一类型返回值


如果返回值是同一类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型

使用return语句返回时，值列表的顺序需要与函数声明的返回值类型一致

纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，
无法区分每个返回参数的意义


2. 带有变量名的返回值

go语言支持返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型
命名的返回值变量的默认值为类型的默认值，即数值为0，字符串为空字符串，布尔为false,指针为nil


同一类型返回值和命名返回值两种形式只能二选一，

调用函数


返回值变量列表 = 函数名(参数列表)
Go语言将秒转换为具体的时间































