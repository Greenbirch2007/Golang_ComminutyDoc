
多重赋值在go语言的错误处理和函数返回值中会大量使用


匿名变量不占用内存空间，不会分配内存。
匿名变量与匿名变量之间也不会因为多次声明而无法使用

一个变量(常量，类型或函数)在程序中都有一定的作用范围，称为作用于


函数内定义的变量称为局部变量
函数外定义的变量称为全局变量
函数定义中的变量称为形式参数





全局变量
在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，
就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用"import"
关键字引入全局变量所在源文件之后才能使用这个全局变量


全局变量必须以var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写

go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑


形式参数

在定义函数时函数后面括号中的变量叫做形式参数

形式参数只在函数调用时才会生效，函数调用结束后就会销毁，
在函数未被调用时，函数的形参并不占用实际的额存储单元，也没有实际值


形式参数会作为函数的局部变量来使用


转义字符串

\n :　换行符
\r : 回车符
\t : tab 键
\u 或\U ：Unicode字符
\\ :反斜杠自身


字符串实现基于UTF-8编码

go语言中字符串的内部实现使用utf-8编码，通过rune类型，可以方便地堆每个UTF-8
字符进行访问。
也支持按照传统的ASCII码方式逐字符进行访问


使用双引号写字符串的方式，称为字符串字面量

这种双引号不能跨行，如果想要在源码中嵌入一个多行字符串时，
就必须使用`反引号

在这种方式下，反引号换行将被作为字符串中的换行，但是所有的转义字符均微笑，文本将会
原样输出

fmt.Sprintf(格式化输出)

fmt.Sprintf(格式化样式，参数列表)

格式化样式：　　字符串形式，格式化动词以%开头
参数列表：　　多个参数以逗号分隔，个数必须与格式化样式中的个数一一对应，否则运行是会报错


StringBuilder　的机制来进行搞笑的字符串连接

bytes.Buffer是可以缓冲病可以往里面写入各种字节数组的。
字符串也是一种字节数组，使用WriteString()方法进行写入

将需要连接的字符串，通过调用WriteString()方法，写入stringBuilder中，然后
再通过stringBuild.String()方法将缓冲转换为字符串


声明字节缓冲
把字符串写入缓冲
将缓冲以字符串输出

GO语言的字符串无法直接修改每一个字符元素，只能通过重新构造新的字符串并
赋值给原来的字符串变量实现

ｇｏ中字符串是不可变的

字符串不可变的很多好处
天生线程安全，都是只读对象，无须加锁；方便内幕才能内存共享，
而不必使用写时赋值(Copy On Write)等技术，
字符串hashy值也只需要制作一份

[]byte在go语言中是可变的，本身就是以切片


go语言中的字符串是不可变的
修改字符串时，可以将字符串转换为[]byte进行修改
[]byte和string可以通过强制类型转换

go内建函数 len()可以用来获取字符串，切片，通道channel的差大怒



一般游戏中咋登录时都需要输入名字，而名字一般有长度限制。
考虑到使用中午的名字，就需要检测字符串的UTF-8格式的长度

ASCII字符串长度使用len()函数
Unicode字符串长度使用utf8.Rune.CountingString()函数。。

遍历字符串的两个方法

遍历每一个ASCII字符

遍历ASCII字符使用for的数值循环进行遍历，直接取每个字符串的下边获取ASCII字符


由于没有使用Unicode，汉子没显示为乱码

按Unicode字符遍历字符串


Ascii字符串已办理直接使用下标
Unicode字符串遍历用for range


字符串截取(获取字符串的每一段字符)
获取字符串的某一段字符是开发中常用的操作，一般将字符串中的某一段字符叫做
子串(substring)


string.Index()函数在字符串中搜索另外一个子串

字符串索引比较常用的方法\
strings.Index:正向搜索子字符串
strings.LastIndex:反向搜索子字符串
搜索的起始位置可以通过切片偏移制作

字符串中的灭一个元素叫做“字符”，在百丽或单个获取字符串元素时可以获得字符


go的字符有两种


1. uint8类型，或byte类型，代表ASCII码的一个字符

2. rune类型，代表一个utf-8 处理中文，日文是
需要用到rune类型，rune类型等价于int32类型

byte类型是uint8的别名

go也支持Unicode(UTF-8)，字符同样称为Unicode代码点或runes
并在内存中使用int来表示。

在书写Unicode字符时，需要在16进制数之前加上前缀\u或\U
因为Unicode至少占用2个字节，
所以我们使用init16或int类型来表示

如果需要使用到4个字节，则使用\u前缀
格式化说明%c用于表示字符
当和字符配合使用时，%v或%d会输出用于表示该字符的整数

%U输出格式为U+hhhh的字符串


Unicode包中的用于测试字符的函数，返回布尔值


ch代表字符

判断是否为字母：unicode.IsLetter(ch)
潘丹是否为数字:unicode.IsDigit(ch)
判断是否为空白符号：  unicode.IsSpace(ch)

在必要可行的情况下，一个类型的值可以被转换为另一个类型的值。
由于go语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明

valueOfTypeB = typeB(valueOfTypeA)


类型B的值 = 类型B(类型A的值)


a:=5.0
b :=int(a)

类型转换只能在定义正确的情况下转换成
只有相同底层类型的变量之间可以进行相互转换

不同底层类型的变量相互转换时会引发编译错误(如将bool类型转换为int类型)


浮点数在转换为整型时，会将小数部分去掉，只保留整数部分


go提供了控制数据结构指针的能力
不能进行指针运算
go允许控制特定集合的数据结构，分配的数据以及内存访问模式。
指针是系统编程，操作系统或网络应用常用的变量

指针(pointer)在go中分拆为两部分

1.类型指针
2. 切片


类型指针，允许堆这个指针了新的数据进行修改，传递数据可以直接使用指针
而不需拷贝主句，类型指针不能进行偏移和运算

切片，由指向起始元素的原始指针，元素数量和容量组成


受益于这样的约束和拆分，go语言的指针类型变量即拥有指针高小访问的特点，又不会
发生指针偏移，
从而避免非法修改关键性数据的问题。
垃圾回收也比较容易堆不会发生便宜的指针进行检索和回收

切片比原始指针更安全，
切片在发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃


操作系统使用c语言及指针进行编写

指针地址，指针类型，指针取值

认识指针地址和指针而理性

一个指针变量可以指向一个值的内存你地址，它所指向的值的内存地址32和64位
机器上分配4或8个字节，
占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配
到任何变量时，它的默认值为nil
指针变量通常缩写为 ptr

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置

go语言中使用在变量名前添加&操作符(前缀）来获取变量的内存地址(取地址操作）

ptr := &v // v的类型T

其中v代表被取地址的变量，变量v的地址使用变量ptr进行接收
ptr的类型为 *T，称作T的指针类型
*代表指针

变量，指针，地址  每个变量都有地址，这个地址就是指针的值

从指针获取指针指向的值

当使用&操作符对普通变量进行取地址操作并得到变量的指针后，
可以对象指针使用*操作，也就是指针



取地址操作符&和取值操作符*是一对互补操作
&取地址，
×根据地址取出地址指向的指向的值


变量，指针地址，指针变量，取地址，取值的关系

1.对变量进行取地址操作使用&,可以获得这个变量的指针变量
2. 指针变量的值是指针地址

& 指针地址，指针类型
× 取值
&× 指针取值




3. 对指针变量进行取值操作*,可以获得指针变量指向的原变量的值


使用指针修改值

铜鼓欧指针不仅可以取值，也可以修改值


示例： 使用指针变量获取命令行的输入细腻系


flag包实现了堆命令行的解析
flag包使得开发命令行工具更加简单


通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数
经过flag包的解析后即可获取命令行的数据

创建指针的方法--new()函数


new(类型)


new()函数可以创建一个对应类型的指针，创建过程会分配内存
被床架你的指针指向默认值
Go逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。

指针

foo()函数返回一个局部变量的指针

foo函数里的变量t逃逸了，

堆上动态分配内存比栈上静态分配内存，开销大很多

const ，用于存储不会改变的数据

const pi = 3.14

const iota

无类型常量


const+iota 间接实现枚举

枚举类型转换为字符串


type 关键字(类型别名)


type byte = uint8
type rune = int32


type TypeAlias = Type

类型别名和类型定义

非本地类型不能定义方法

在结构体成员嵌入时使用别名

 结构体重命名类似继承类


go的语法元素5个
标识符
关键字
操作符
分隔符
字面量


break default func interface select
case defer go map struct
chan else goto package switch
const fallthrough if range type
continue for import return var 



append bool byte cap close complex complex64 complex128
unit16 copy false float32 float64 imag int int8 int16
uint32 int32 int64 iota len make new nil  
panic uint64 print println real recover
string true uint uint8 uintptr


